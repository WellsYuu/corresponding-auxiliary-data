package com.jiagouedu.services.manage.attribute.impl;import com.jiagouedu.core.ServersManager;import com.jiagouedu.services.manage.attribute.AttributeService;import com.jiagouedu.services.manage.attribute.bean.Attribute;import com.jiagouedu.services.manage.attribute.dao.AttributeDao;import com.jiagouedu.services.manage.attributelink.dao.AttributeLinkDao;import org.apache.commons.lang.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.util.LinkedList;import java.util.List;@Service("attributeServiceManage")public class AttributeServiceImpl extends ServersManager<Attribute, AttributeDao> implements        AttributeService {	private static final Logger logger = LoggerFactory.getLogger(AttributeServiceImpl.class);    @Resource(name = "attributeLinkDaoManage")	private AttributeLinkDao attributeLinkDao;    @Override    @Resource(name = "attributeDaoManage")    public void setDao(AttributeDao attributeDao) {        this.dao = attributeDao;    }	public void setAttributeLinkDao(AttributeLinkDao attributeLinkDao) {		this.attributeLinkDao = attributeLinkDao;	}	/**	 * 插入父属性和批量的子属性集合	 */	public int insert(Attribute e) {		logger.error("AttributeServiceImpl.insert...");		if(StringUtils.isBlank(e.getAttrNames0())){			throw new NullPointerException("主属性不能为空！添加失败！");		}		//		if(e.getAttrNames()==null || e.getAttrNames().length==0){//			throw new NullPointerException("attrNames is null");//		}		int id = 0;//父属性/参数ID		if(StringUtils.isNotBlank(e.getId())){			id = Integer.valueOf(e.getId());			//更新主属性			dao.update(e);			//删除已经插入的子属性的数据//			dao.deleteByPid(id);		}else{			//插入父属性			id = dao.insert(e);		}				logger.error("AttributeServiceImpl.insert.id"+id);		if(id==0){			throw new RuntimeException("id is error:"+id);		}				if(StringUtils.isBlank(e.getIdList0())){			//插入主属性			Attribute attr0 = new Attribute();			attr0.setName(e.getAttrNames0());			attr0.setOrder1(e.getOrder1List0());			attr0.setPid(id);			dao.insert(attr0);		}else{			//修改主属性			Attribute attr0 = new Attribute();			attr0.setName(e.getAttrNames0());			attr0.setOrder1(e.getOrder1List0());			attr0.setPid(id);			attr0.setId(e.getIdList0());			dao.update(attr0);		}				logger.error("idList0 = " + e.getIdList0()+",attrNames0="+e.getAttrNames0());		if(e.getIdList()==null){			logger.error("e.getIdList().length=0");		}else{			logger.error("e.getIdList().length="+e.getIdList().length);			for(int i=0;i<e.getIdList().length;i++){				logger.error("e.getIdList()[i] = "+e.getIdList()[i]+",i="+i);			}		}				if(e.getAttrNames()==null){			logger.error("e.getAttrNames().length=0");		}else{			logger.error("e.getAttrNames().length="+e.getAttrNames().length);			for(int i=0;i<e.getAttrNames().length;i++){				logger.error("e.getAttrNames()[i] = "+e.getAttrNames()[i]+",i="+i);			}		}				/**		 * //组装子属性对象集合并插入		 */		if(e.getAttrNames()!=null && e.getIdList()!=null){			List<Attribute> updatelist = new LinkedList<Attribute>();						if(e.getAttrNames().length==(e.getIdList().length+1)){				logger.error(">>数量相等");				//数量相等				for(int i=0;i<e.getIdList().length;i++){					Attribute attr = new Attribute();					attr.setName(e.getAttrNames()[i+1]);					attr.setOrder1(e.getOrder1List()[i+1]);					attr.setPid(id);					attr.setId(e.getIdList()[i]);										updatelist.add(attr);				}								logger.error(">>数量相等updatelist="+updatelist.size());				if(updatelist.size()>0){					for(int i=0;i<updatelist.size();i++){						dao.update(updatelist.get(i));					}				}			}else{				logger.error(">>数量不相等");				//数量不相等				//update				for(int i=0;i<e.getIdList().length;i++){					Attribute attr = new Attribute();					attr.setName(e.getAttrNames()[i+1]);					attr.setOrder1(e.getOrder1List()[i+1]);					attr.setPid(id);					attr.setId(e.getIdList()[i]);										updatelist.add(attr);					e.getAttrNames()[i+1] = null;				}								List<Attribute> insertList = new LinkedList<Attribute>();				//insert				for(int i=0;i<e.getAttrNames().length;i++){					if(StringUtils.isBlank(e.getAttrNames()[i])){						continue;					}					Attribute attr = new Attribute();					attr.setName(e.getAttrNames()[i]);					attr.setOrder1(e.getOrder1List()[i]);					attr.setPid(id);										insertList.add(attr);				}								logger.error(">>数量不相等updatelist="+updatelist.size()+",insertList="+insertList.size());				if(updatelist.size()>0){					for(int i=0;i<updatelist.size();i++){						dao.update(updatelist.get(i));					}				}				if(insertList.size()>0){					for(int i=0;i<insertList.size();i++){						dao.insert(insertList.get(i));					}				}			}		}else if(e.getAttrNames()!=null && e.getIdList()==null){			//insert			//组装子属性对象集合并插入			for(int i=0;i<e.getAttrNames().length;i++){				if(StringUtils.isNotBlank(e.getAttrNames()[i])){					Attribute attr = new Attribute();					attr.setName(e.getAttrNames()[i]);					attr.setPid(id);					dao.insert(attr);				}			}		}else{			throw new NullPointerException("非法请求！");		}		logger.error("AttributeServiceImpl.insert.id,return."+id);		return id;	}		/**	 * 删除商品属性数据，需要同时删除该属性下的子属性 以及 attributeLink表的关联数据	 *///	public int delete(Attribute e) {//		super.delete(e);//		dao.deleteByPid(e);//		return 1;//	}		/**	 * 需哟重写父类的此方法	 * 批量删除	 * 	 * 删除商品属性数据，需要同时删除该属性下的子属性 以及 attributeLink表的关联数据	 * 	 * 无论你删除的是商品属性还是商品参数，此方法都会根据选择的ID集合区删除所有的数据，主要包括：主属性表的数据、该主属性下的所有子属性、属性关联表的数据	 * .并且是事物控制的删除。	 * @param ids	 * @return	 */	public int deletes(String[] ids) {		if (ids != null && ids.length > 0) {			for (int i = 0; i < ids.length; i++) {				logger.error("deleteAllById.id="+ids[i]);				if(StringUtils.isBlank(ids[i])){					throw new NullPointerException();				}				int id = Integer.parseInt(ids[i]);								//删除attributeLink表的相关联的数据				attributeLinkDao.deleteByAttributeId(id);								//根据PID删除选择属性下 的所有子属性				dao.deleteByPid(id);								//根据ID删除选择的属性				dao.deleteById(id);								//由于mybatis不支持同一个statment下执行多个SQL语句，所以只能写多个方法先解决，以后发现有好的方法了再改进。//				dao.deleteAllById(id);			}		}		return 0;	}	@Override	public int selectCount(Attribute ee) {		return dao.selectCount(ee);	}}